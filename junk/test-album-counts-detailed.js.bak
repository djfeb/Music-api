require('dotenv').config();
const fs = require('fs').promises;
const path = require('path');
const mysql = require('mysql2/promise');

const dbConfig = {
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
};

// Function to normalize strings for comparison
function normalize(str) {
    return str.toLowerCase()
        .replace(/[^\w\s]/g, '') // Remove special characters
        .replace(/\s+/g, ' ')    // Normalize spaces
        .trim();
}

// Function to calculate similarity between two strings
function stringSimilarity(str1, str2) {
    const norm1 = normalize(str1);
    const norm2 = normalize(str2);
    return norm1 === norm2;
}

async function getArtistAlbums(connection, artistName) {
    try {
        // Get albums with their tracks
        const [albums] = await connection.execute(`
            SELECT DISTINCT 
                a.id as album_id, 
                a.name as album_name,
                t.id as track_id,
                t.name as track_name,
                t.download_status,
                t.album_id
            FROM albums a
            JOIN tracks t ON t.album_id = a.id
            JOIN artist_tracks at ON at.track_id = t.id
            JOIN artists art ON art.id = at.artist_id
            WHERE art.name LIKE ?
            ORDER BY a.name, t.name
        `, [`%${artistName}%`]);

        // Group tracks by album
        const albumMap = new Map();
        for (const row of albums) {
            if (!albumMap.has(row.album_id)) {
                albumMap.set(row.album_id, {
                    id: row.album_id,
                    name: row.album_name,
                    tracks: []
                });
            }
            albumMap.get(row.album_id).tracks.push({
                id: row.track_id,
                name: row.track_name,
                status: row.download_status
            });
        }

        return Array.from(albumMap.values());
    } catch (error) {
        console.error('Error fetching albums from database:', error);
        return [];
    }
}

async function getDownloadedAlbums(artistName) {
    const downloadPath = path.join(__dirname, 'downloads', artistName);
    try {
        const albums = new Map();
        
        try {
            await fs.access(downloadPath);
        } catch {
            console.log(`No downloads found for ${artistName}`);
            return albums;
        }

        const entries = await fs.readdir(downloadPath, { withFileTypes: true });
        
        for (const entry of entries) {
            if (entry.isDirectory()) {
                const albumPath = path.join(downloadPath, entry.name);
                const tracks = [];
                
                const trackDirs = await fs.readdir(albumPath, { withFileTypes: true });
                for (const trackDir of trackDirs) {
                    if (trackDir.isDirectory()) {
                        const trackPath = path.join(albumPath, trackDir.name);
                        const trackFiles = await fs.readdir(trackPath);
                        const mp3Files = trackFiles.filter(file => file.endsWith('.mp3'));
                        
                        if (mp3Files.length > 0) {
                            tracks.push({
                                id: trackDir.name,  // This is the track ID we used in the folder name
                                name: mp3Files[0].replace('.mp3', ''),
                                path: path.join(trackPath, mp3Files[0])
                            });
                        }
                    }
                }
                
                if (tracks.length > 0) {
                    albums.set(entry.name, {
                        name: entry.name,
                        tracks: tracks
                    });
                }
            }
        }
        
        return albums;
    } catch (error) {
        console.error('Error reading downloaded albums:', error);
        return new Map();
    }
}

function findMatchingAlbum(albumName, albumsList) {
    for (const album of albumsList) {
        if (stringSimilarity(albumName, album.name)) {
            return album;
        }
    }
    return null;
}

async function fixMissingTracks(connection, missingTracks) {
    if (missingTracks.length === 0) {
        console.log('\nNo tracks to fix!');
        return;
    }

    console.log('\n=== Starting to fix missing tracks ===');
    console.log(`Found ${missingTracks.length} tracks to fix\n`);

    const results = {
        success: [],
        failed: []
    };

    for (const track of missingTracks) {
        console.log(`Processing: ${track.name} (Album: ${track.albumName})`);
        
        // Reset the track status to trigger a new download
        try {
            await connection.execute(
                'UPDATE tracks SET download_status = ? WHERE id = ?',
                ['not_downloaded', track.id]
            );
            console.log(`✓ Reset status for: ${track.name}`);
            
            // If there's a partial download directory, clean it up
            const downloadPath = path.join(
                __dirname, 
                'downloads', 
                'Taylor Swift',
                track.albumName,
                track.id
            );

            try {
                const dirContents = await fs.readdir(downloadPath);
                console.log(`Found existing directory for ${track.name}, cleaning up...`);
                
                for (const file of dirContents) {
                    await fs.unlink(path.join(downloadPath, file))
                        .catch(err => console.error(`  Error deleting ${file}:`, err.message));
                }
                
                await fs.rmdir(downloadPath)
                    .catch(err => console.error(`  Error removing directory:`, err.message));
                
                console.log(`✓ Cleaned up directory for: ${track.name}`);
            } catch (err) {
                if (err.code !== 'ENOENT') {
                    console.error(`  Error accessing directory for ${track.name}:`, err.message);
                }
            }
        } catch (err) {
            console.error(`× Failed to process ${track.name}:`, err.message);
        }
    }

    console.log('\n=== Finished processing missing tracks ===');
    console.log('You can now run the main download script to download these tracks.');
}

async function main() {
    const artistName = 'Taylor Swift';
    let connection;
    const missingTracks = [];

    try {
        connection = await connectToDatabase();
        
        // Get albums from database
        console.log(`\nFetching albums for ${artistName} from database...`);
        const dbAlbums = await getArtistAlbums(connection, artistName);
        console.log(`Found ${dbAlbums.length} albums in database\n`);

        // Get downloaded albums
        console.log(`Checking downloaded albums for ${artistName}...`);
        const downloadedAlbums = await getDownloadedAlbums(artistName);
        console.log(`Found ${downloadedAlbums.size} downloaded albums\n`);

        console.log('Detailed Comparison:\n');
        console.log('1. Albums Present in Both:');
        console.log('-------------------------');

        // Compare each database album
        for (const dbAlbum of dbAlbums) {
            let downloadedAlbum = null;
            
            // Try to find matching downloaded album
            for (const [name, album] of downloadedAlbums) {
                if (stringSimilarity(dbAlbum.name, name)) {
                    downloadedAlbum = album;
                    break;
                }
            }

            if (downloadedAlbum) {
                console.log(`\nAlbum: ${dbAlbum.name}`);
                console.log(`Database tracks: ${dbAlbum.tracks.length}`);
                console.log(`Downloaded tracks: ${downloadedAlbum.tracks.length}`);

                // Compare tracks
                const missingTracks = dbAlbum.tracks.filter(dbTrack => 
                    !downloadedAlbum.tracks.some(dlTrack => dlTrack.id === dbTrack.id)
                );

                const extraTracks = downloadedAlbum.tracks.filter(dlTrack => 
                    !dbAlbum.tracks.some(dbTrack => dbTrack.id === dlTrack.id)
                );

                if (missingTracks.length > 0) {
                    console.log('\n  Missing tracks:');
                    missingTracks.forEach(track => {
                        console.log(`  - ${track.name} (ID: ${track.id}, Status: ${track.status})`);
                        // Add to global missing tracks list
                        missingTracks.push({
                            id: track.id,
                            name: track.name,
                            status: track.status,
                            albumName: dbAlbum.name
                        });
                    });
                }

                if (extraTracks.length > 0) {
                    console.log('\n  Extra downloaded tracks:');
                    extraTracks.forEach(track => {
                        console.log(`  - ${track.name} (ID: ${track.id})`);
                    });
                }

                if (missingTracks.length === 0 && extraTracks.length === 0) {
                    console.log('  ✓ All tracks match');
                }
            }
        }

        console.log('\n2. Albums Only in Database:');
        console.log('-------------------------');
        for (const dbAlbum of dbAlbums) {
            if (![...downloadedAlbums.keys()].some(name => stringSimilarity(name, dbAlbum.name))) {
                console.log(`\n${dbAlbum.name}`);
                console.log('Tracks:');
                dbAlbum.tracks.forEach(track => {
                    console.log(`- ${track.name} (Status: ${track.status})`);
                });
            }
        }

        console.log('\n3. Albums Only in Downloads:');
        console.log('-------------------------');
        for (const [name, album] of downloadedAlbums) {
            if (!dbAlbums.some(dbAlbum => stringSimilarity(dbAlbum.name, name))) {
                console.log(`\n${name}`);
                console.log('Tracks:');
                album.tracks.forEach(track => {
                    console.log(`- ${track.name}`);
                });
            }
        }

    } catch (error) {
        console.error('An error occurred:', error);
    } finally {
        // Automatically fix missing tracks
        if (missingTracks.length > 0) {
            console.log('\n=== Missing Tracks Summary ===');
            console.log('The following tracks will be fixed:');
            missingTracks.forEach(track => {
                console.log(`- ${track.name} (Album: ${track.albumName})`);
                console.log(`  Status: ${track.status}, ID: ${track.id}`);
            });

            console.log('\nAutomatically fixing missing tracks...');
            await fixMissingTracks(connection, missingTracks);
        }

        if (connection) {
            await connection.end();
        }
    }
}

async function connectToDatabase() {
    try {
        return await mysql.createConnection(dbConfig);
    } catch (error) {
        console.error('Failed to connect to database:', error);
        throw error;
    }
}

main().catch(console.error);
